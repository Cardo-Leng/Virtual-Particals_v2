<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI è™šæ‹Ÿç²’å­ v10.3 (å¤šç«¯é€‚é…ç‰ˆ)</title>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        #video-container {
            position: absolute; bottom: 20px; left: 20px;
            width: 160px; height: 120px;
            border-radius: 12px; overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10; transform: scaleX(-1); pointer-events: none;
            transition: all 0.3s ease;
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        #ui-container {
            position: absolute; top: 20px; right: 20px;
            background: rgba(10, 10, 15, 0.85); backdrop-filter: blur(16px);
            padding: 24px; border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: white; z-index: 100; display: flex; flex-direction: column;
            gap: 16px; width: 260px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            transition: all 0.3s ease;
            max-height: 90vh; /* é˜²æ­¢UIè¶…å‡ºå±å¹• */
            overflow-y: auto; /* å…è®¸å°å±æ»šåŠ¨ */
        }
        /* éšè—æ»šåŠ¨æ¡ä½†ä¿ç•™åŠŸèƒ½ */
        #ui-container::-webkit-scrollbar { width: 0; height: 0; }

        h3 { margin: 0; font-size: 14px; font-weight: 600; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        .grid-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        button {
            background: rgba(255, 255, 255, 0.08); border: none; color: white;
            padding: 12px; border-radius: 10px; cursor: pointer;
            transition: all 0.2s ease; font-size: 14px; font-weight: 500;
        }
        button:hover { background: rgba(255, 255, 255, 0.15); }
        button.active { background: #00d2ff; color: #000; font-weight: 700; box-shadow: 0 0 15px rgba(0, 210, 255, 0.4); }
        button.active-universe { 
            background: #7b2cbf; color: #fff; font-weight: 700; 
            box-shadow: 0 0 25px rgba(123, 44, 191, 0.5); 
            background-image: linear-gradient(135deg, #3c096c, #9d4edd); border: 1px solid rgba(255,255,255,0.2);
        }
        button.active-heart {
            background: #e91e63; color: #fff; font-weight: 700;
            box-shadow: 0 0 20px rgba(233, 30, 99, 0.6);
        }

        .switch-container { display: flex; justify-content: space-between; align-items: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 12px; }
        .switch-label { font-size: 14px; font-weight: 600; }
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #444; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 22px; width: 22px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #30d158; }
        input:checked + .slider:before { transform: translateX(22px); }

        .color-wrapper { display: flex; align-items: center; justify-content: space-between; min-height: 40px; }
        input[type="color"] { -webkit-appearance: none; appearance: none; border: none; width: 40px; height: 32px; cursor: pointer; background: none; padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid rgba(255,255,255,0.8); border-radius: 8px; }
        
        #btn-regen {
            display: none; width: 100%; background: linear-gradient(90deg, #43cea2, #185a9d); 
            font-weight: bold; text-shadow: 0 1px 2px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2);
        }
        #btn-regen:active { transform: scale(0.98); }

        #status { font-size: 12px; color: #00d2ff; text-align: center; margin-top: 5px; min-height: 16px; }
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #00d2ff; font-size: 18px; z-index: 200; pointer-events: none; transition: opacity 0.5s; text-align: center; width: 100%; }

        /* ================= ç§»åŠ¨ç«¯é€‚é…æ ·å¼ ================= */
        @media screen and (max-width: 768px) {
            #ui-container {
                top: 10px; right: 10px; left: 10px; /* æ’‘æ»¡å®½åº¦ï¼Œç•™è¾¹è· */
                width: auto;
                padding: 16px;
                gap: 12px;
            }
            #video-container {
                width: 120px; height: 90px; /* ç¼©å°é¢„è§ˆçª—å£ */
                bottom: 15px; left: 15px;
            }
            .grid-buttons {
                grid-template-columns: repeat(3, 1fr); /* æ‰‹æœºä¸Šä¸€è¡Œ3ä¸ªæŒ‰é’® */
            }
            #btn-hand { grid-column: span 3 !important; } /* æ‰‹éƒ¨è¿½è¸ªæŒ‰é’®å æ»¡ä¸€è¡Œ */
            
            h3 { font-size: 12px; }
            button { padding: 10px; font-size: 12px; }
            #status { font-size: 11px; }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">ç³»ç»Ÿåˆå§‹åŒ–ä¸­...<br><span style="font-size:12px; color:#aaa">è¯·å…è®¸æ‘„åƒå¤´æƒé™</span></div>

    <div id="ui-container">
        <h3>ç³»ç»Ÿè®¾ç½®</h3>
        <div class="switch-container">
            <span class="switch-label">è‡ªåŠ¨æ—‹è½¬ (é™æ€)</span>
            <label class="toggle-switch">
                <input type="checkbox" id="rotationToggle" checked>
                <span class="slider"></span>
            </label>
        </div>

        <h3>æ¨¡å‹é€‰æ‹©</h3>
        <div class="grid-buttons">
            <button onclick="setShape('hand')" class="active" id="btn-hand" style="grid-column: span 2; background: rgba(255, 255, 255, 0.15); font-weight:bold;">ğŸ– å®æ—¶åŒæ‰‹è¿½è¸ª</button>
            <button onclick="setShape('heart')" id="btn-heart">â¤ï¸ ç”Ÿå‘½ä¹‹å¿ƒ</button>
            <button onclick="setShape('universe')" id="btn-universe">ğŸŒŒ æ·±ç©ºå®‡å®™</button>
            <button onclick="setShape('saturn')" id="btn-saturn">ğŸª çœŸå®åœŸæ˜Ÿ</button>
            <button onclick="setShape('flower')" id="btn-flower">ğŸŒ¸ åŠ¨æ€èŠ±æœµ</button>
        </div>

        <div class="color-wrapper" id="color-section">
            <h3 id="color-label">ç²’å­é¢œè‰²</h3>
            <input type="color" id="colorPicker" value="#ff69b4">
            <button id="btn-regen" onclick="regenerateUniverse()">ğŸ² é‡æ„æ˜Ÿç³»ç»“æ„</button>
        </div>

        <div id="status">ç­‰å¾…æ‰‹åŠ¿è¯†åˆ«...</div>
    </div>

    <div id="video-container">
        <video id="input_video" playsinline webkit-playsinline></video>
    </div>

    <script>
        // ================= å…¨å±€å˜é‡ä¸é…ç½® =================
        const MAX_HANDS = 2; 
        const TOTAL_PARTICLES = 58000; 
        const PARTICLES_PER_HAND = Math.floor(TOTAL_PARTICLES / MAX_HANDS); 
        
        const HAND_SCALE_BASE = 180; 
        const ARM_LENGTH = 400; 
        
        // è®¾å¤‡æ£€æµ‹å˜é‡
        let isMobileDevice = false;

        let scene, camera, renderer, particles, geometry, material;
        let targetPositions = new Float32Array(TOTAL_PARTICLES * 3);
        let currentPositions = new Float32Array(TOTAL_PARTICLES * 3);
        let targetColors = new Float32Array(TOTAL_PARTICLES * 3);
        
        let handScales = new Float32Array(MAX_HANDS).fill(0); 
        let currentShape = 'hand'; 
        let multiHandLandmarks = []; 
        let userSelectedColor = new THREE.Color(0xff69b4); 
        let isAutoRotation = true;
        
        let handOpenFactor = 0; 
        let mainHandRotation = { x:0, y:0, z:0 };
        let heartBeatPhase = 0; 

        // å­˜å‚¨åœŸæ˜Ÿé£æš´çš„å®æ—¶çŠ¶æ€
        let saturnStorms = []; 
        let stormParticlesData = []; 

        // ================= å®‡å®™é£æš´å˜é‡ (Type 1) =================
        let universeStorms = []; 
        let universeStormParticlesData = []; 

        // ================= å®‡å®™æ¼©æ¶¡æ˜Ÿç³»å˜é‡ (Type 3) =================
        let spiralGalaxies = [];
        let spiralGalaxyParticlesData = [];
        // =========================================================

        const HAND_CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],
            [0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],
            [0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]
        ];

        // ================= è®¾å¤‡æ£€æµ‹å‡½æ•° =================
        function detectDevice() {
            const ua = navigator.userAgent.toLowerCase();
            isMobileDevice = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(ua);
            console.log("Device Detected:", isMobileDevice ? "Mobile" : "Desktop");
            return isMobileDevice;
        }

        // ================= Three.js åˆå§‹åŒ– =================
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.0015);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.z = 500;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            geometry = new THREE.BufferGeometry();
            
            const initialColors = [];
            for (let i = 0; i < TOTAL_PARTICLES; i++) {
                currentPositions[i * 3] = (Math.random() - 0.5) * 800;
                currentPositions[i * 3 + 1] = (Math.random() - 0.5) * 800;
                currentPositions[i * 3 + 2] = (Math.random() - 0.5) * 800;
                initialColors.push(0.5, 0.5, 0.5);
                targetColors[i*3] = userSelectedColor.r;
                targetColors[i*3+1] = userSelectedColor.g;
                targetColors[i*3+2] = userSelectedColor.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(initialColors, 3));

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
            
            material = new THREE.PointsMaterial({
                size: 3, 
                map: sprite,
                vertexColors: true,
                sizeAttenuation: true,
                alphaTest: 0.5,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            setShape('hand');
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        // ================= æ ¸å¿ƒå½¢çŠ¶è®¡ç®—é€»è¾‘ (ä¿æŒåŸæ ·) =================
        function calculateStaticShape(type) {
            const RENDER_SIZE = 180;
            if (type === 'universe') {
                calculateUniverse();
                return;
            }

            const ur = userSelectedColor.r, ug = userSelectedColor.g, ub = userSelectedColor.b;
            
            let baseR = ur, baseG = ug, baseB = ub;
            if (type === 'saturn' && document.getElementById('colorPicker').value === "#ff69b4") {
                baseR = 0.9; baseG = 0.82; baseB = 0.65; 
            }

            // åœŸæ˜Ÿé£æš´åˆå§‹åŒ–
            const STORM_PARTICLE_COUNT = 3000; 
            const STORM_COUNT = 6;
            
            if (type === 'saturn') {
                saturnStorms = [];
                stormParticlesData = [];
                for(let s=0; s<STORM_COUNT; s++) {
                    const isNorth = (s < 3); 
                    const basePhi = isNorth ? (0.4 + Math.random()*0.6) : (2.1 + Math.random()*0.6);
                    saturnStorms.push({
                        idx: s,
                        isNorth: isNorth,
                        phi: basePhi,
                        theta: Math.random() * Math.PI * 2,
                        radius: 12 + Math.random() * 10,
                        eyeRadius: 3 + Math.random() * 2,
                        speed: (0.5 + Math.random() * 1.5) * (isNorth ? 1 : -1),
                        driftSpeed: (Math.random() - 0.5) * 0.2
                    });
                }
            }
            
            for (let i = 0; i < TOTAL_PARTICLES; i++) {
                let x=0, y=0, z=0;
                let tr = ur, tg = ug, tb = ub; 

                if (type !== 'saturn') {
                    tr = ur + (Math.random()-0.5)*0.1;
                    tg = ug + (Math.random()-0.5)*0.1;
                    tb = ub + (Math.random()-0.5)*0.1;
                }

                if (type === 'saturn') {
                    if (i < STORM_PARTICLE_COUNT) {
                        const stormIdx = i % STORM_COUNT;
                        const storm = saturnStorms[stormIdx];
                        const localR = storm.eyeRadius + Math.random() * (storm.radius - storm.eyeRadius);
                        const localAngle = Math.random() * Math.PI * 2;
                        
                        stormParticlesData[i] = {
                            stormIdx: stormIdx,
                            localR: localR,
                            localAngle: localAngle,
                            yOffset: (Math.random() - 0.5) * 3
                        };
                        x = 0; y = 0; z = 0; 
                        tr = 1.0; tg = 1.0; tb = 1.0;
                    } else {
                        tr = baseR; tg = baseG; tb = baseB;
                        const isRing = Math.random() > 0.45; 
                        if (isRing) {
                            const minR = 1.2; const maxR = 2.3;
                            let rNorm = minR + Math.random() * (maxR - minR);
                            let brightness = 1.0; let densityThreshold = 1.0;

                            if (rNorm < 1.5) { brightness = 0.4; densityThreshold = 0.4; }
                            else if (rNorm < 1.95) { brightness = 1.15; densityThreshold = 1.0; } 
                            else if (rNorm < 2.02) { brightness = 0.1; densityThreshold = 0.05; } 
                            else { brightness = 0.9; densityThreshold = 0.85; } 

                            if (Math.random() > densityThreshold) {
                                rNorm = 1.52 + Math.random() * 0.41; brightness = 1.15;
                            }

                            const rRing = rNorm * RENDER_SIZE;
                            const texture = 0.8 + 0.2 * Math.cos(rRing * 0.8);
                            brightness *= texture;

                            const tRing = Math.random() * Math.PI * 2;
                            x = rRing * Math.cos(tRing); 
                            z = rRing * Math.sin(tRing); 
                            y = (Math.random()-0.5) * 3;

                            tr *= brightness; tg *= brightness; tb *= brightness;
                            const noise = (Math.random() - 0.5) * 0.15;
                            tr += noise; tg += noise; tb += noise;

                        } else {
                            const rPlanet = RENDER_SIZE;
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos(2 * Math.random() - 1);
                            let modR = rPlanet;
                            if (phi < 0.25) { 
                                const hexEffect = 0.08 * Math.sin(phi * Math.PI * 4); 
                                modR = rPlanet * (1.0 + hexEffect * Math.cos(6 * theta));
                                tr *= 0.85; tg *= 0.85; tb *= 0.9; 
                            }
                            x = modR * Math.sin(phi) * Math.cos(theta);
                            y = modR * Math.cos(phi);
                            z = modR * Math.sin(phi) * Math.sin(theta);
                            const bandPhase = y * 0.18 + Math.random()*0.05;
                            const band = Math.sin(bandPhase); 
                            if (band > 0.35) { tr += 0.15; tg += 0.15; tb += 0.1; } 
                            else if (band < -0.35) { tr -= 0.12; tg -= 0.12; tb -= 0.08; }
                        }
                    }
                } else if (type === 'flower') {
                    const isCenter = (Math.random() > 0.85); 
                    if(isCenter) { tr = 1.0; tg = 0.95; tb = 0.6; }
                } else if(type === 'heart') {
                    const isVessel = Math.random() < 0.60; 
                    if (isVessel) {
                        const vesselType = Math.random() > 0.5 ? 'artery' : 'vein'; 
                        let found = false; let attempt = 0;
                        while (!found && attempt < 50) {
                            const h = (Math.random() * 230) - 100; 
                            const angle = Math.random() * Math.PI * 2;
                            const rad = Math.sqrt(Math.random()) * 10.8; 
                            if (vesselType === 'artery') {
                                const curveX = 10 + 5 * Math.sin(h * 0.025);
                                const curveZ = -10 + 10 * Math.cos(h * 0.03);
                                x = curveX + rad * Math.cos(angle); z = curveZ + rad * Math.sin(angle); y = h;
                                tr = 0.3; tg = 0.0; tb = 0.0; 
                            } else {
                                const curveX = -25 - 10 * Math.sin(h * 0.02);
                                const curveZ = 5 + 15 * Math.sin(h * 0.025);
                                x = curveX + rad * Math.cos(angle); z = curveZ + rad * Math.sin(angle); y = h;
                                tr = 0.0; tg = 0.05; tb = 0.35;
                            }
                            found = true; attempt++;
                        }
                    } else {
                        let found = false; let attempt = 0;
                        while (!found && attempt < 100) {
                            let u = (Math.random() * 2 - 1) * 1.5; let v = (Math.random() * 2 - 1) * 1.5; let w = (Math.random() * 2 - 1) * 1.5; 
                            let deformX = u; if (u > 0) deformX *= 1.3; 
                            const xx = deformX * deformX; const yy = v * v; const zz = w * w;
                            const group = xx + (9/4) * yy + zz - 1;
                            const val = group * group * group - xx * w * w * w - (9/80) * yy * w * w * w;
                            if (val < 0) {
                                x = u * 100; y = w * 100; z = v * 100; 
                                x += (Math.random() - 0.5) * 2; y += (Math.random() - 0.5) * 2; z += (Math.random() - 0.5) * 2;
                                const depth = Math.min(1.0, Math.abs(val) * 3.0); 
                                const surfaceColor = { r: 1.0, g: 0.15, b: 0.3 }; 
                                const coreColor = { r: 0.25, g: 0.02, b: 0.05 };
                                tr = THREE.MathUtils.lerp(surfaceColor.r, coreColor.r, depth);
                                tg = THREE.MathUtils.lerp(surfaceColor.g, coreColor.g, depth);
                                tb = THREE.MathUtils.lerp(surfaceColor.b, coreColor.b, depth);
                                found = true;
                            }
                            attempt++;
                        }
                        if (!found) { x=0; y=0; z=0; }
                    }
                } else if(type !== 'hand' && type !== 'flower') {
                      const r = RENDER_SIZE * Math.cbrt(Math.random());
                      const theta = Math.random() * Math.PI * 2;
                      const phi = Math.acos(2 * Math.random() - 1);
                      x = r * Math.sin(phi) * Math.cos(theta);
                      y = r * Math.sin(phi) * Math.sin(theta);
                      z = r * Math.cos(phi);
                }
                
                if (type !== 'flower') {
                    targetPositions[i * 3] = x; 
                    targetPositions[i * 3 + 1] = y; 
                    targetPositions[i * 3 + 2] = z;
                }
                targetColors[i*3] = tr; 
                targetColors[i*3+1] = tg; 
                targetColors[i*3+2] = tb;
            }
        }

        function updateFlowerTargets(bloomFactor) {
            const RENDER_SIZE = 220;
            const PETAL_COUNT = 7; 
            const openAngleBase = THREE.MathUtils.lerp(1.2, -0.6, bloomFactor); 

            for (let i = 0; i < TOTAL_PARTICLES; i++) {
                const uniqueVal = (Math.sin(i * 12.9898) * 43758.5453) % 1; 
                const uniqueVal2 = (Math.cos(i * 24.632) * 54321.9876) % 1;
                const petalIdx = i % PETAL_COUNT;
                const angleStep = (Math.PI * 2) / PETAL_COUNT;
                const baseRotation = petalIdx * angleStep;
                const u = Math.abs(uniqueVal); 
                const v = uniqueVal2 - 0.5;
                const r = u * RENDER_SIZE; 
                const widthProfile = 80 * Math.sin(u * Math.PI) * Math.pow(u, 0.3);
                const localX = v * widthProfile;
                const curveStrength = 40 + (bloomFactor * 50);
                const localY = Math.pow(u, 2) * curveStrength;
                const pitchAngle = openAngleBase + (u * 0.3); 
                let pz = r * Math.cos(pitchAngle) - localY * Math.sin(pitchAngle);
                let py = r * Math.sin(pitchAngle) + localY * Math.cos(pitchAngle);
                let px = localX; 
                const finalX = px * Math.cos(baseRotation) - pz * Math.sin(baseRotation);
                const finalZ = px * Math.sin(baseRotation) + pz * Math.cos(baseRotation);
                const finalY = py;
                targetPositions[i * 3]     = finalX;
                targetPositions[i * 3 + 1] = finalY;
                targetPositions[i * 3 + 2] = finalZ;
            }
        }

        // ================= 3. å®‡å®™ç®—æ³• (ä¸å¸¦ç²’å­å¢å¼ºç‰ˆ) (ä¿æŒåŸæ ·) =================
        function calculateUniverse() {
            const RENDER_SIZE = 220;
            const bounds = { a: RENDER_SIZE * 2.5, b: RENDER_SIZE * 1.5, c: RENDER_SIZE * 2.2 }; 
            let particleIdx = 0;

            // ================== Type 1: é£æš´ (ä¿æŒä¸å˜) ==================
            universeStorms = [];
            universeStormParticlesData = [];
            const UNIVERSE_STORM_COUNT = 4;
            const PARTICLES_PER_STORM = 3000; 
            
            for(let s = 0; s < UNIVERSE_STORM_COUNT; s++) {
                const dir = (s < 2) ? 1 : -1; 
                const hasSolidCore = (s >= 2); 
                const stormRadius = (40 + Math.random() * 30) * 0.5;
                const rotSpeed = (0.5 + Math.random() * 1.5) * dir * 0.5;

                universeStorms.push({
                    idx: s, hasSolidCore: hasSolidCore,
                    x: (Math.random() - 0.5) * 200, y: (Math.random() - 0.5) * 100, z: (Math.random() - 0.5) * 150,
                    vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5, vz: (Math.random() - 0.5) * 0.5,
                    rotationSpeed: rotSpeed, color: new THREE.Color().setHSL(Math.random(), 0.9, 0.6),
                    tiltX: (Math.random() - 0.5) * Math.PI, tiltZ: (Math.random() - 0.5) * Math.PI, radius: stormRadius
                });

                for(let k = 0; k < PARTICLES_PER_STORM; k++) {
                    if (particleIdx >= TOTAL_PARTICLES) break;
                    let localR, localAngle, yOffset;
                    const isRingParticle = k > PARTICLES_PER_STORM * 0.8;

                    if (isRingParticle) {
                        const minRingR = stormRadius * 1.1; const maxRingR = stormRadius * 1.8;
                        const rNorm = minRingR + Math.random() * (maxRingR - minRingR);
                        const density = 0.5 + 0.5 * Math.sin(rNorm * 20.0);
                        localR = (Math.random() > density) ? (minRingR + Math.random() * (maxRingR - minRingR)) : rNorm;
                        localAngle = Math.random() * Math.PI * 2; yOffset = (Math.random() - 0.5) * 0.5;
                    } else {
                        if (hasSolidCore) {
                            if (k < PARTICLES_PER_STORM * 0.3) {
                                const planetRadius = stormRadius * 0.35; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1); const rSphere = Math.cbrt(Math.random()) * planetRadius; 
                                const sx = rSphere * Math.sin(phi) * Math.cos(theta); const sy = rSphere * Math.cos(phi); const sz = rSphere * Math.sin(phi) * Math.sin(theta);
                                localR = Math.sqrt(sx*sx + sz*sz); localAngle = Math.atan2(sz, sx); yOffset = sy; 
                            } else {
                                localR = Math.random() * stormRadius; localAngle = Math.random() * Math.PI * 2; yOffset = (Math.random() - 0.5) * 6; 
                            }
                        } else {
                            const eyeRadius = stormRadius * 0.3; localR = eyeRadius + Math.random() * (stormRadius - eyeRadius); localAngle = Math.random() * Math.PI * 2; yOffset = (Math.random() - 0.5) * 8;
                        }
                    }
                    universeStormParticlesData[particleIdx] = { stormIdx: s, localR: localR, localAngle: localAngle, yOffset: yOffset };
                    const storm = universeStorms[s]; const c = storm.color; let r = c.r, g = c.g, b = c.b;
                    if (isRingParticle) { r *= 0.8; g *= 0.8; b *= 0.8; } else if (hasSolidCore && k < PARTICLES_PER_STORM * 0.3) { r *= 1.4; g *= 1.4; b *= 1.4; }
                    targetColors[particleIdx * 3] = r + (Math.random()-0.5)*0.2; targetColors[particleIdx * 3 + 1] = g + (Math.random()-0.5)*0.2; targetColors[particleIdx * 3 + 2] = b + (Math.random()-0.5)*0.2;
                    targetPositions[particleIdx * 3] = 0; targetPositions[particleIdx * 3 + 1] = 0; targetPositions[particleIdx * 3 + 2] = 0;
                    particleIdx++;
                }
            }

            // ================== Type 2: å½©è™¹ä¸å¸¦æ˜Ÿäº‘ Â ==================
            const RIBBON_COUNT = 2;
            const PARTICLES_PER_RIBBON = 10000; // ç²’å­æ•°
            for (let r = 0; r < RIBBON_COUNT; r++) {
                const startX = (Math.random() - 0.5) * bounds.a * 1.5; const endX = (Math.random() - 0.5) * bounds.a * 1.5;
                const startZ = (Math.random() - 0.5) * bounds.c * 1.5; const endZ = (Math.random() - 0.5) * bounds.c * 1.5;
                const centerY = (Math.random() - 0.5) * bounds.b * 0.8;
                const waveFreq = 1.5 + Math.random() * 2; const waveAmp = 40 + Math.random() * 40; 
                const baseHue = r === 0 ? 0.0 : 0.5; 

                const baseWidth = 80 + Math.random() * 40; 

                for (let k = 0; k < PARTICLES_PER_RIBBON; k++) {
                    if (particleIdx >= TOTAL_PARTICLES) break;
                    const t = k / PARTICLES_PER_RIBBON;
                    let px = THREE.MathUtils.lerp(startX, endX, t); let pz = THREE.MathUtils.lerp(startZ, endZ, t);
                    let py = centerY + Math.sin(t * Math.PI * waveFreq) * waveAmp + Math.cos(t * Math.PI * waveFreq * 1.5) * (waveAmp*0.5);
                    
                    const currentWidth = baseWidth * (0.4+0.6*Math.sin(t * Math.PI)); 
                    
                    const widthRandomFactor = (Math.random() - 0.5);
                    
                    px += widthRandomFactor * currentWidth; 
                    py += (Math.random() - 0.5) * currentWidth * 0.3; 
                    pz += (Math.random() - 0.5) * currentWidth * 0.5;

                    targetPositions[particleIdx * 3] = px; targetPositions[particleIdx * 3 + 1] = py; targetPositions[particleIdx * 3 + 2] = pz;
                    
                    let hue;
                    if (r === 0) {
                         hue = baseHue + t * 0.4; 
                    } else {
                         hue = baseHue + (widthRandomFactor + 0.5) * 0.4;
                    }
                    
                    const ribbonColor = new THREE.Color().setHSL(hue % 1.0, 0.8, 0.6);
                    targetColors[particleIdx * 3] = ribbonColor.r; targetColors[particleIdx * 3 + 1] = ribbonColor.g; targetColors[particleIdx * 3 + 2] = ribbonColor.b;
                    particleIdx++;
                }
            }

            // ================== Type 3: æ¼©æ¶¡çŠ¶æ˜Ÿç³» ==================
            spiralGalaxies = [];
            spiralGalaxyParticlesData = [];
            const GALAXY_COUNT = 5; 
            const PARTICLES_PER_GALAXY = 1500;

            for (let g = 0; g < GALAXY_COUNT; g++) {
                const centerX = (Math.random() - 0.5) * bounds.a * 1.2;
                const centerY = (Math.random() - 0.5) * bounds.b * 0.8;
                const centerZ = (Math.random() - 0.5) * bounds.c * 1.2;
                
                const radius = 350 + Math.random() * 250; 
                
                const arms = Math.floor(2 + Math.random() * 3); 
                
                const spinSpeed = (0.005 + Math.random() * 0.01) * (Math.random() > 0.5 ? 1 : -1);
                
                const tiltX = (Math.random() - 0.5) * 1.0; const tiltZ = (Math.random() - 0.5) * 1.0;

                spiralGalaxies.push({ idx: g, x: centerX, y: centerY, z: centerZ, tiltX, tiltZ, currentAngle: 0, spinSpeed });

                const centerColor = new THREE.Color(0xffddaa); 
                let armColorHex;
                if (g===0) armColorHex = 0x44aaff;
                else if (g===1) armColorHex = 0xaa44ff;
                else if (g===2) armColorHex = 0x44ffaa; 
                else armColorHex = 0xff44aa; 
                const armColor = new THREE.Color(armColorHex); 

                for (let k = 0; k < PARTICLES_PER_GALAXY; k++) {
                      if (particleIdx >= TOTAL_PARTICLES) break;
                      const t = Math.pow(Math.random(), 2.5);
                      const r = t * radius;
                      const armIdx = k % arms;
                      const armOffset = (armIdx / arms) * Math.PI * 2;
                      const angle = t * Math.PI * 8 + armOffset + (Math.random()-0.5)*(1.5 - t);

                      spiralGalaxyParticlesData[particleIdx] = {
                          galaxyIdx: g, localR: r, localAngle: angle,
                          yOffset: (Math.random() - 0.5) * (30 * Math.pow(1-t, 2)) 
                      };

                      const finalColor = centerColor.clone().lerp(armColor, Math.pow(t, 0.7));
                      targetColors[particleIdx * 3] = finalColor.r + (Math.random()-0.5)*0.1;
                      targetColors[particleIdx * 3 + 1] = finalColor.g + (Math.random()-0.5)*0.1;
                      targetColors[particleIdx * 3 + 2] = finalColor.b + (Math.random()-0.5)*0.1;

                      targetPositions[particleIdx*3] = 0; targetPositions[particleIdx*3+1] = 0; targetPositions[particleIdx*3+2] = 0;
                      particleIdx++;
                }
            }

            // ================== èƒŒæ™¯æ˜Ÿäº‘ (ä½¿ç”¨å‰©ä½™ç²’å­) ==================
            // æ³¨æ„ï¼šç”±äºä¸å¸¦ç²’å­å¤§å¹…å¢åŠ ï¼ŒremainingParticles ä¼šå‡å°‘ï¼Œä»è€Œè‡ªåŠ¨â€œä»è¾¹ç•Œè½®å»“ç²’å­ä¸­åˆ†é…â€
            const hullCount = Math.floor((TOTAL_PARTICLES - particleIdx) * 0.3); 
            const hullHue = Math.random();
            const hullColor = new THREE.Color().setHSL(hullHue, 0.8, 0.9);
            
            for (let i = 0; i < hullCount; i++) {
                if (particleIdx >= TOTAL_PARTICLES) break;
                const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                const noise = 1.0 + 0.15 * (Math.sin(theta*6) + Math.cos(phi*5)); const r = noise;
                targetPositions[particleIdx * 3]     = bounds.a * r * Math.sin(phi) * Math.cos(theta);
                targetPositions[particleIdx * 3 + 1] = bounds.b * r * Math.sin(phi) * Math.sin(theta);
                targetPositions[particleIdx * 3 + 2] = bounds.c * r * Math.cos(phi);
                targetColors[particleIdx * 3]     = hullColor.r + (Math.random()-0.5)*0.1;
                targetColors[particleIdx * 3 + 1] = hullColor.g + (Math.random()-0.5)*0.1;
                targetColors[particleIdx * 3 + 2] = hullColor.b + (Math.random()-0.5)*0.1;
                particleIdx++;
            }

            const remainingParticles = TOTAL_PARTICLES - particleIdx;
            const clusterCount = 15 + Math.floor(Math.random() * 10);
            if (clusterCount > 0 && remainingParticles > 0) {
                let particlesPerCluster = Math.floor(remainingParticles / clusterCount);
                for (let c = 0; c < clusterCount; c++) {
                    const cx = (Math.random() - 0.5) * 2 * bounds.a * 0.8; const cy = (Math.random() - 0.5) * 2 * bounds.b * 0.8; const cz = (Math.random() - 0.5) * 2 * bounds.c * 0.8;
                    const typeRoll = Math.random(); let clusterType = typeRoll < 0.4 ? 'sphere' : (typeRoll < 0.7 ? 'ring' : 'stream');
                    const clusterBaseColor = new THREE.Color().setHSL(Math.random(), 0.8, 0.5 + Math.random()*0.2);
                    const count = (c === clusterCount - 1) ? (TOTAL_PARTICLES - particleIdx) : particlesPerCluster;
                    for (let k = 0; k < count; k++) {
                        if (particleIdx >= TOTAL_PARTICLES) break;
                        let lx=0, ly=0, lz=0; 
                        if (clusterType === 'sphere') {
                             const radius = 40 + Math.random() * 60; const phi = Math.acos(2 * Math.random() - 1); const theta = Math.random() * Math.PI * 2; const r = (Math.random() * radius) * (Math.random() < 0.5 ? 0.3 : 1.0);
                             lx = r * Math.sin(phi) * Math.cos(theta); ly = r * Math.sin(phi) * Math.sin(theta); lz = r * Math.cos(phi);
                        } else if (clusterType === 'ring') {
                             const radius = 30 + Math.random() * 60; const theta = Math.random() * Math.PI * 2; const r = (radius * 0.4) + Math.random() * (radius * 0.6);
                             lx = r * Math.cos(theta); lz = r * Math.sin(theta); ly = (Math.random() - 0.5) * 10; const tiltX = (Math.random()-0.5); const tiltZ = (Math.random()-0.5); ly += lx * tiltX + lz * tiltZ;
                        } else {
                             const length = 80 + Math.random() * 120; const t = Math.random(); lx = (t - 0.5) * length; ly = Math.sin(t * Math.PI * 2) * 15 + (Math.random()-0.5)*10; lz = Math.cos(t * Math.PI * 2) * 15 + (Math.random()-0.5)*10;
                             const rotY = Math.random() * Math.PI; const nx = lx * Math.cos(rotY) - lz * Math.sin(rotY); const nz = lx * Math.sin(rotY) + lz * Math.cos(rotY); lx = nx; lz = nz;
                        }
                        targetPositions[particleIdx * 3] = cx + lx; targetPositions[particleIdx * 3 + 1] = cy + ly; targetPositions[particleIdx * 3 + 2] = cz + lz;
                        targetColors[particleIdx * 3] = clusterBaseColor.r + (Math.random()-0.5)*0.1; targetColors[particleIdx * 3 + 1] = clusterBaseColor.g + (Math.random()-0.5)*0.1; targetColors[particleIdx * 3 + 2] = clusterBaseColor.b + (Math.random()-0.5)*0.1;
                        particleIdx++;
                    }
                }
            }
        }

        function updateSingleHandParticles(landmarks, handIndex) {
            const startIndex = handIndex * PARTICLES_PER_HAND;
            const endIndex = startIndex + PARTICLES_PER_HAND;
            const handParticleCount = Math.floor(PARTICLES_PER_HAND * 0.7);
            const handEndIndex = startIndex + handParticleCount;

            let pIndex = startIndex;
            const particlesPerBone = Math.floor(handParticleCount / HAND_CONNECTIONS.length);

            HAND_CONNECTIONS.forEach(pair => {
                const start = landmarks[pair[0]];
                const end = landmarks[pair[1]];
                for (let i = 0; i < particlesPerBone; i++) {
                    if (pIndex >= handEndIndex) break;
                    const t = Math.random();
                    let tx = (0.5 - (start.x + (end.x - start.x) * t)) * HAND_SCALE_BASE * 2.5;
                    let ty = (0.5 - (start.y + (end.y - start.y) * t)) * HAND_SCALE_BASE * 2.5;
                    let tz = -(start.z + (end.z - start.z) * t) * HAND_SCALE_BASE * 2.0;
                    const spread = 8 * (1.0 - t * 0.5);
                    tx += (Math.random() - 0.5) * spread; ty += (Math.random() - 0.5) * spread; tz += (Math.random() - 0.5) * spread;
                    targetPositions[pIndex * 3] = tx; targetPositions[pIndex * 3 + 1] = ty; targetPositions[pIndex * 3 + 2] = tz;
                    pIndex++;
                }
            });

            const wrist = landmarks[0];
            const middleMCP = landmarks[9];
            let dx = wrist.x - middleMCP.x; let dy = wrist.y - middleMCP.y; let dz = wrist.z - middleMCP.z;
            const len = Math.sqrt(dx*dx + dy*dy + dz*dz); dx /= len; dy /= len; dz /= len;
            const wristX = (0.5 - wrist.x) * HAND_SCALE_BASE * 2.5;
            const wristY = (0.5 - wrist.y) * HAND_SCALE_BASE * 2.5;
            const wristZ = -wrist.z * HAND_SCALE_BASE * 2.0;

            for (let i = handEndIndex; i < endIndex; i++) {
                const t = Math.random();
                const dist = t * ARM_LENGTH;
                let tx = wristX + (-dx) * dist; let ty = wristY + (-dy) * dist; let tz = wristZ + (-dz) * dist;
                const armSpread = 15 + Math.pow(t, 2) * 100;
                tx += (Math.random() - 0.5) * armSpread; ty += (Math.random() - 0.5) * armSpread; tz += (Math.random() - 0.5) * armSpread;
                targetPositions[i * 3] = tx; targetPositions[i * 3 + 1] = ty; targetPositions[i * 3 + 2] = tz;
            }
        }

        function regenerateUniverse() {
            if (currentShape === 'universe') {
                calculateUniverse();
            }
        }

        function setShape(shape) {
            currentShape = shape;
            document.querySelectorAll('.grid-buttons button').forEach(b => {
                b.className = ''; 
            });
            
            const btn = document.getElementById(`btn-${shape}`);
            if (shape === 'universe') {
                btn.classList.add('active-universe');
                document.getElementById('colorPicker').style.display = 'none';
                document.getElementById('btn-regen').style.display = 'block';
                document.getElementById('color-label').innerText = "å®‡å®™æ„é€ ";
            } else if (shape === 'heart') {
                btn.classList.add('active-heart');
                document.getElementById('colorPicker').style.display = 'block';
                document.getElementById('btn-regen').style.display = 'none';
                document.getElementById('color-label').innerText = "ç²’å­é¢œè‰²";
            } else {
                btn.classList.add('active');
                document.getElementById('colorPicker').style.display = 'block';
                document.getElementById('btn-regen').style.display = 'none';
                document.getElementById('color-label').innerText = "ç²’å­é¢œè‰²";
            }
            
            if (shape !== 'hand') {
                calculateStaticShape(shape); 
                document.getElementById('rotationToggle').disabled = false;
                particles.rotation.set(0,0,0);
                
                if (shape === 'flower') {
                    particles.position.y = -60; 
                    updateFlowerTargets(0.5);
                    if(document.getElementById('colorPicker').value === "#00d2ff") {
                        document.getElementById('colorPicker').value = "#ff69b4";
                        userSelectedColor.set("#ff69b4");
                    }
                } else if (shape === 'heart') {
                    particles.position.y = 0;
                    if(document.getElementById('colorPicker').value === "#00d2ff") {
                        document.getElementById('colorPicker').value = "#e91e63";
                        userSelectedColor.set("#e91e63");
                    }
                } else {
                    particles.position.y = 0; 
                }

            } else {
                document.getElementById('rotationToggle').disabled = true;
                particles.rotation.set(0,0,0);
                particles.position.y = 0; 
                const ur = userSelectedColor.r, ug = userSelectedColor.g, ub = userSelectedColor.b;
                for(let i=0; i<TOTAL_PARTICLES; i++) {
                    targetColors[i*3] = ur; targetColors[i*3+1] = ug; targetColors[i*3+2] = ub;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const timeNow = Date.now() * 0.001; 

            let targetHandScreenScale = 1.0;
            if (multiHandLandmarks.length > 0) {
                 const p1 = multiHandLandmarks[0][0]; 
                 const p2 = multiHandLandmarks[0][9]; 
                 const dx = p1.x - p2.x;
                 const dy = p1.y - p2.y;
                 const dist = Math.sqrt(dx*dx + dy*dy);
                 targetHandScreenScale = dist * 9.0; 
                 targetHandScreenScale = THREE.MathUtils.clamp(targetHandScreenScale, 0.4, 3.0);
            }

            if (currentShape === 'flower') {
                const targetBloom = (multiHandLandmarks.length > 0) ? handOpenFactor : 0.5;
                updateFlowerTargets(targetBloom);
            }

            if (currentShape === 'saturn' && saturnStorms.length > 0) {
                const RENDER_SIZE = 180;
                saturnStorms.forEach(storm => {
                    storm.theta += storm.driftSpeed * 0.02; 
                    const wave = Math.sin(timeNow * 0.5 + storm.idx) * 0.002;
                    storm.phi += wave;
                });
                for (let i = 0; i < 3000; i++) {
                    const data = stormParticlesData[i];
                    if (!data) continue;
                    const storm = saturnStorms[data.stormIdx];
                    const currentRot = data.localAngle + timeNow * storm.speed;
                    const localX = data.localR * Math.cos(currentRot);
                    const localZ = data.localR * Math.sin(currentRot);
                    const cx = RENDER_SIZE * Math.sin(storm.phi) * Math.cos(storm.theta);
                    const cy = RENDER_SIZE * Math.cos(storm.phi);
                    const cz = RENDER_SIZE * Math.sin(storm.phi) * Math.sin(storm.theta);
                    const nx = Math.sin(storm.phi) * Math.cos(storm.theta);
                    const ny = Math.cos(storm.phi);
                    const nz = Math.sin(storm.phi) * Math.sin(storm.theta);
                    const tx = -Math.sin(storm.theta); const ty = 0; const tz = Math.cos(storm.theta);
                    const bx = ny * tz - nz * ty; const by = nz * tx - nx * tz; const bz = nx * ty - ny * tx;
                    targetPositions[i*3]   = cx + localX * tx + localZ * bx + data.yOffset * nx;
                    targetPositions[i*3+1] = cy + localX * ty + localZ * by + data.yOffset * ny;
                    targetPositions[i*3+2] = cz + localX * tz + localZ * bz + data.yOffset * nz;
                }
            }

            // ================= å®‡å®™åŠ¨ç”»æ›´æ–° =================
            if (currentShape === 'universe') {
                // --- Type 1: é£æš´åŠ¨ç”» ---
                if (universeStorms.length > 0) {
                    const bounds = { x: 120, y: 60, z: 100 }; 
                    universeStorms.forEach(storm => {
                        storm.x += storm.vx; storm.y += storm.vy; storm.z += storm.vz;
                        if (Math.abs(storm.x) > bounds.x) storm.vx *= -1;
                        if (Math.abs(storm.y) > bounds.y) storm.vy *= -1;
                        if (Math.abs(storm.z) > bounds.z) storm.vz *= -1;
                    });
                    
                    // ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„é£æš´ç²’å­æ€»æ•° (4 * 3000 = 12000)
                    const totalStormParticles = universeStorms.length * 3000; 
                    for(let i = 0; i < totalStormParticles; i++) {
                        const data = universeStormParticlesData[i]; if(!data) continue;
                        const storm = universeStorms[data.stormIdx];
                        const currentRot = data.localAngle + timeNow * storm.rotationSpeed;
                        let lx = data.localR * Math.cos(currentRot); let lz = data.localR * Math.sin(currentRot); let ly = data.yOffset;
                        let y1 = ly * Math.cos(storm.tiltX) - lz * Math.sin(storm.tiltX); let z1 = ly * Math.sin(storm.tiltX) + lz * Math.cos(storm.tiltX);
                        let xFinal = lx * Math.cos(storm.tiltZ) - y1 * Math.sin(storm.tiltZ); let yFinal = lx * Math.sin(storm.tiltZ) + y1 * Math.cos(storm.tiltZ); let zFinal = z1;
                        targetPositions[i*3] = storm.x + xFinal; targetPositions[i*3 + 1] = storm.y + yFinal; targetPositions[i*3 + 2] = storm.z + zFinal;
                    }
                }

                // --- Type 3: æ¼©æ¶¡æ˜Ÿç³»åŠ¨ç”» (æ›´æ–°ç‰ˆ) ---
                if (spiralGalaxies.length > 0) {
                    spiralGalaxies.forEach(gal => { gal.currentAngle += timeNow * gal.spinSpeed; });
                    
                    // ä¿®å¤ï¼šè®¡ç®—æ˜Ÿç³»ç²’å­çš„èµ·å§‹ç´¢å¼•ï¼šé£æš´(4*3000) + ä¸å¸¦(2*8000) = 12000 + 16000 = 28000
                    const galaxyStartIdx = (universeStorms.length * 3000) + (2 * 8000); 
                    const totalGalaxyParticles = spiralGalaxies.length * 1500;

                    for(let i = 0; i < totalGalaxyParticles; i++) {
                        const pIdx = galaxyStartIdx + i;
                        const data = spiralGalaxyParticlesData[pIdx]; if(!data) continue;
                        const galaxy = spiralGalaxies[data.galaxyIdx];
                        const finalAngle = data.localAngle + galaxy.currentAngle;
                        
                        let lx = data.localR * Math.cos(finalAngle); let lz = data.localR * Math.sin(finalAngle); let ly = data.yOffset;
                        let y1 = ly * Math.cos(galaxy.tiltX) - lz * Math.sin(galaxy.tiltX); let z1 = ly * Math.sin(galaxy.tiltX) + lz * Math.cos(galaxy.tiltX);
                        let xFinal = lx * Math.cos(galaxy.tiltZ) - y1 * Math.sin(galaxy.tiltZ); let yFinal = lx * Math.sin(galaxy.tiltZ) + y1 * Math.cos(galaxy.tiltZ); let zFinal = z1;
                        targetPositions[pIdx*3]     = galaxy.x + xFinal;
                        targetPositions[pIdx*3 + 1] = galaxy.y + yFinal;
                        targetPositions[pIdx*3 + 2] = galaxy.z + zFinal;
                    }
                }
            }

            if (currentShape === 'hand') {
                for (let i = 0; i < MAX_HANDS; i++) {
                    if (i < multiHandLandmarks.length) {
                        const landmarks = multiHandLandmarks[i];
                        updateSingleHandParticles(landmarks, i);
                        const wristZ = landmarks[0].z;
                        let s = (wristZ + 0.2) * 3.0;
                        handScales[i] = THREE.MathUtils.clamp(s, 0.4, 2.5);
                    } else {
                        handScales[i] = THREE.MathUtils.lerp(handScales[i], 0, 0.1); 
                    }
                }
                particles.rotation.set(0,0,0);
            } 
            else {
                let hasHand = multiHandLandmarks.length > 0;
                if (isAutoRotation) {
                    particles.rotation.y += 0.0015; 
                    let targetX = (currentShape === 'universe' || currentShape === 'flower' || currentShape === 'saturn') ? 0.3 : 0;
                    particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, targetX, 0.05); 
                    particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, 0, 0.05);
                } else if (hasHand) {
                    particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, mainHandRotation.x, 0.1);
                    particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, mainHandRotation.y, 0.1);
                    particles.rotation.z = THREE.MathUtils.lerp(particles.rotation.z, mainHandRotation.z, 0.1);
                }
            }

            let heartBeatScale = 1.0;
            let beatFreq = 0; 
            
            if (currentShape === 'heart') {
                let targetFreq = THREE.MathUtils.mapLinear(targetHandScreenScale, 0.5, 2.5, 0.4, 1.0);
                targetFreq = THREE.MathUtils.clamp(targetFreq, 0.4, 1.0);
                beatFreq = targetFreq;
                const dt = 0.016; 
                heartBeatPhase += dt * targetFreq * Math.PI * 2;
                const beat = Math.pow(Math.sin(heartBeatPhase), 6); 
                heartBeatScale = 1.0 + (beat * 0.15); 
            }

            const positions = geometry.attributes.position.array;
            const colors = geometry.attributes.color.array;
            
            for (let i = 0; i < TOTAL_PARTICLES; i++) {
                const handIndex = Math.floor(i / PARTICLES_PER_HAND);
                let effectiveScale = 1.0;
                
                if (currentShape === 'hand') {
                    effectiveScale = handScales[handIndex];
                } else {
                    if (multiHandLandmarks.length > 0) {
                        if (currentShape === 'flower') {
                            effectiveScale = targetHandScreenScale;
                        } else if (currentShape === 'heart') {
                            effectiveScale = targetHandScreenScale * heartBeatScale;
                        } else if (currentShape === 'saturn') {
                             effectiveScale = targetHandScreenScale * 0.8; 
                        } else {
                            effectiveScale = 0.6 + (handOpenFactor * 2.2);
                        }
                    } else {
                        const time = Date.now() * 0.001;
                        if (currentShape === 'heart') {
                             const autoBeat = Math.pow(Math.sin(time * 0.6 * Math.PI * 2), 6);
                             effectiveScale = 0.8 * (1.0 + autoBeat * 0.15);
                        } else {
                             effectiveScale = 0.8 + Math.sin(time * 0.8) * 0.05; 
                        }
                    }
                }

                const px = positions[i*3], py = positions[i*3+1], pz = positions[i*3+2];
                const tx = targetPositions[i*3], ty = targetPositions[i*3+1], tz = targetPositions[i*3+2];
                const cr = colors[i*3], cg = colors[i*3+1], cb = colors[i*3+2];
                let tr = targetColors[i*3], tg = targetColors[i*3+1], tb = targetColors[i*3+2];

                if (currentShape === 'heart') {
                    if (tb > 0.3 && tr < 0.1) {
                        const wave = (Math.sin((ty - timeNow * 150) * 0.05) + 1) * 0.5;
                        const flow = Math.pow(wave, 10); 
                        tr += flow * 0.1; tg += flow * 0.8; tb = Math.min(1.0, tb + flow * 0.9); 
                    }
                    else if (tr > 0.25 && tb < 0.1 && tg < 0.1) {
                        const wave = (Math.sin((ty + timeNow * 150) * 0.05) + 1) * 0.5;
                        const flow = Math.pow(wave, 10); 
                        tr = Math.min(1.0, tr + flow * 0.9); tg += flow * 0.4; tb += flow * 0.2;
                    }
                }

                const posSpeed = (currentShape === 'hand' || currentShape === 'flower' || currentShape === 'heart' || currentShape === 'saturn' || currentShape === 'universe') ? (currentShape === 'universe' ? 0.06 : 0.2) : 0.04;
                
                positions[i*3]   += (tx * effectiveScale - px) * posSpeed;
                positions[i*3+1] += (ty * effectiveScale - py) * posSpeed;
                positions[i*3+2] += (tz * effectiveScale - pz) * posSpeed;

                const colSpeed = 0.08; 
                colors[i*3]   += (tr - cr) * colSpeed;
                colors[i*3+1] += (tg - cg) * colSpeed;
                colors[i*3+2] += (tb - cb) * colSpeed;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
            
            updateHeartStatus(beatFreq);
        }

        function updateHeartStatus(freq) {
             const statusElement = document.getElementById('status');
             if (currentShape === 'heart' && multiHandLandmarks.length > 0) {
                 const bpm = Math.round(freq * 60);
                 statusElement.innerText = `ç”Ÿç‰©å¿ƒè„ | å¿ƒç‡: ${bpm} BPM | é è¿‘åŠ é€Ÿ`;
                 statusElement.style.color = "#e91e63";
             }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onResults(results) {
            document.getElementById('loader').style.opacity = 0;
            multiHandLandmarks = results.multiHandLandmarks || [];

            if (multiHandLandmarks.length > 0) {
                const primaryHand = multiHandLandmarks[0];
                const palm = primaryHand[0];
                const fingertips = [4, 8, 12, 16, 20];
                let totalDist = 0;
                fingertips.forEach(idx => {
                    const tip = primaryHand[idx];
                    totalDist += Math.sqrt(Math.pow(tip.x - palm.x, 2) + Math.pow(tip.y - palm.y, 2));
                });
                
                let rawFactor = (totalDist / 5 - 0.1) * 3.5;
                handOpenFactor = Math.max(0, Math.min(1, rawFactor));

                if (!isAutoRotation) {
                    const wrist = primaryHand[0];
                    const mid = primaryHand[9];
                    const dx = mid.x - wrist.x;
                    const dy = mid.y - wrist.y;
                    mainHandRotation.z = (Math.atan2(dy, dx) + Math.PI / 2);
                    mainHandRotation.x = (primaryHand[12].z - wrist.z) * 3.0;
                    mainHandRotation.y = (primaryHand[17].z - primaryHand[5].z) * 3.0;
                }
            } else {
                handOpenFactor = 0;
            }

            const statusElement = document.getElementById('status');
            const deviceTypeStr = isMobileDevice ? "ç§»åŠ¨ç«¯" : "ç”µè„‘ç«¯";

            if (multiHandLandmarks.length > 0) {
                const count = multiHandLandmarks.length;
                if (currentShape === 'hand') {
                    statusElement.innerText = `è¿½è¸ªä¸­: ${count} åªæ‰‹ | ${deviceTypeStr}`;
                    statusElement.style.color = "#30d158";
                } else if (currentShape === 'universe') {
                      statusElement.innerText = isAutoRotation ? "æ·±ç©ºå®‡å®™ | è‡ªåŠ¨æ—‹è½¬" : "æ·±ç©ºå®‡å®™ | æ‰‹åŠ¿æ—‹è½¬";
                      statusElement.style.color = "#9d4edd";
                } else if (currentShape === 'flower') {
                      statusElement.innerText = `èŠ±æœµæ¨¡å¼ | å¼€åˆåº¦: ${Math.round(handOpenFactor*100)}%`;
                      statusElement.style.color = "#ff69b4";
                } else if (currentShape === 'saturn') {
                      statusElement.innerText = "çœŸå®åœŸæ˜Ÿ | é£æš´ç³»ç»Ÿæ´»è·ƒ";
                      statusElement.style.color = "#e0c070";
                } else if (currentShape !== 'heart') {
                    statusElement.innerText = isAutoRotation ? "é™æ€æ¨¡å¼ | è‡ªåŠ¨æ—‹è½¬" : "é™æ€æ¨¡å¼ | æ‰‹åŠ¿æ—‹è½¬";
                    statusElement.style.color = "#00d2ff";
                }
            } else {
                statusElement.innerText = `${deviceTypeStr} | æœªæ£€æµ‹åˆ°æ‰‹åŠ¿`;
                statusElement.style.color = "#aaa";
            }
        }

        // ================= åˆå§‹åŒ–ä¸è¿è¡Œ =================
        detectDevice(); // æ£€æµ‹è®¾å¤‡ç±»å‹

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: MAX_HANDS, 
            modelComplexity: isMobileDevice ? 0 : 1, // ç§»åŠ¨ç«¯é™ä½å¤æ‚åº¦ä»¥æå‡å¸§ç‡
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);
        
        // æ‘„åƒå¤´å‚æ•°ä¼˜åŒ–ï¼šæ ¹æ®è®¾å¤‡ç±»å‹æœ€å¤§åŒ–æ‘„åƒèŒƒå›´
        const cameraConfig = {
            onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
            width: isMobileDevice ? 1280 : 1920, // ç§»åŠ¨ç«¯720pï¼ˆå¹¿è§’ï¼‰ï¼ŒPCç«¯1080p
            height: isMobileDevice ? 720 : 1080,
            facingMode: 'user' // ä¼˜å…ˆä½¿ç”¨å‰ç½®æ‘„åƒå¤´
        };

        const cameraUtils = new Camera(document.getElementById('input_video'), cameraConfig);
        cameraUtils.start();
        
        document.getElementById('rotationToggle').addEventListener('change', (e)=>{isAutoRotation=e.target.checked;});
        document.getElementById('colorPicker').addEventListener('input', (e)=>{
            userSelectedColor.set(e.target.value);
            if(currentShape !== 'universe') {
                const r = userSelectedColor.r, g = userSelectedColor.g, b = userSelectedColor.b;
                if (currentShape === 'flower') {
                      for(let i=0; i<TOTAL_PARTICLES; i++){
                          if (targetColors[i*3] < 0.95) { 
                              targetColors[i*3] = r; targetColors[i*3+1] = g; targetColors[i*3+2] = b;
                          }
                      }
                } else {
                    for(let i=0; i<TOTAL_PARTICLES; i++){
                        targetColors[i*3] = r; targetColors[i*3+1] = g; targetColors[i*3+2] = b;
                    }
                }
            }
        });

        initThree();
    </script>
</body>
</html>
